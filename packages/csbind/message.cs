// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var battleMessage = BattleMessage.FromJson(jsonString);

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class BattleMessage
    {
        [JsonProperty("data", NullValueHandling = NullValueHandling.Ignore)]
        public BattleState Data { get; set; }

        [JsonProperty("sequenceId", NullValueHandling = NullValueHandling.Ignore)]
        public double? SequenceId { get; set; }

        [JsonProperty("type", NullValueHandling = NullValueHandling.Ignore)]
        public TypeEnum? Type { get; set; }
    }

    public partial class BattleState
    {
        [JsonProperty("currentPhase", NullValueHandling = NullValueHandling.Ignore)]
        public BattlePhase? CurrentPhase { get; set; }

        [JsonProperty("currentTurn", NullValueHandling = NullValueHandling.Ignore)]
        public double? CurrentTurn { get; set; }

        [JsonProperty("marks", NullValueHandling = NullValueHandling.Ignore)]
        public MarkMessage[] Marks { get; set; }

        [JsonProperty("players", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerMessage[] Players { get; set; }

        [JsonProperty("status", NullValueHandling = NullValueHandling.Ignore)]
        public BattleStatus? Status { get; set; }

        [JsonProperty("playerA", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerMessage PlayerA { get; set; }

        [JsonProperty("playerB", NullValueHandling = NullValueHandling.Ignore)]
        public PlayerMessage PlayerB { get; set; }

        [JsonProperty("round", NullValueHandling = NullValueHandling.Ignore)]
        public double? Round { get; set; }

        [JsonProperty("reason", NullValueHandling = NullValueHandling.Ignore)]
        public string Reason { get; set; }

        [JsonProperty("winner", NullValueHandling = NullValueHandling.Ignore)]
        public string Winner { get; set; }

        [JsonProperty("currentHp", NullValueHandling = NullValueHandling.Ignore)]
        public double? CurrentHp { get; set; }

        [JsonProperty("fromPet", NullValueHandling = NullValueHandling.Ignore)]
        public string FromPet { get; set; }

        [JsonProperty("player", NullValueHandling = NullValueHandling.Ignore)]
        public Player? Player { get; set; }

        [JsonProperty("toPet", NullValueHandling = NullValueHandling.Ignore)]
        public string ToPet { get; set; }

        [JsonProperty("killer", NullValueHandling = NullValueHandling.Ignore)]
        public string Killer { get; set; }

        [JsonProperty("pet", NullValueHandling = NullValueHandling.Ignore)]
        public string Pet { get; set; }

        [JsonProperty("revivedBy", NullValueHandling = NullValueHandling.Ignore)]
        public string RevivedBy { get; set; }

        [JsonProperty("stage", NullValueHandling = NullValueHandling.Ignore)]
        public double? Stage { get; set; }

        [JsonProperty("stat", NullValueHandling = NullValueHandling.Ignore)]
        public StatTypeOnBattle? Stat { get; set; }

        [JsonProperty("after", NullValueHandling = NullValueHandling.Ignore)]
        public double? After { get; set; }

        [JsonProperty("before", NullValueHandling = NullValueHandling.Ignore)]
        public double? Before { get; set; }

        [JsonProperty("maxHp", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxHp { get; set; }

        [JsonProperty("rageCost", NullValueHandling = NullValueHandling.Ignore)]
        public double? RageCost { get; set; }

        [JsonProperty("skill", NullValueHandling = NullValueHandling.Ignore)]
        public string Skill { get; set; }

        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public string Target { get; set; }

        [JsonProperty("user", NullValueHandling = NullValueHandling.Ignore)]
        public string User { get; set; }

        [JsonProperty("description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("effect", NullValueHandling = NullValueHandling.Ignore)]
        public string Effect { get; set; }

        [JsonProperty("damage", NullValueHandling = NullValueHandling.Ignore)]
        public double? Damage { get; set; }

        [JsonProperty("damageType", NullValueHandling = NullValueHandling.Ignore)]
        public DamageType? DamageType { get; set; }

        [JsonProperty("effectiveness", NullValueHandling = NullValueHandling.Ignore)]
        public double? Effectiveness { get; set; }

        [JsonProperty("isCrit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsCrit { get; set; }

        [JsonProperty("source", NullValueHandling = NullValueHandling.Ignore)]
        public string Source { get; set; }

        [JsonProperty("amount", NullValueHandling = NullValueHandling.Ignore)]
        public double? Amount { get; set; }

        [JsonProperty("healer", NullValueHandling = NullValueHandling.Ignore)]
        public string Healer { get; set; }

        [JsonProperty("attacker", NullValueHandling = NullValueHandling.Ignore)]
        public string Attacker { get; set; }

        [JsonProperty("attackerType", NullValueHandling = NullValueHandling.Ignore)]
        public Element? AttackerType { get; set; }

        [JsonProperty("defenderType", NullValueHandling = NullValueHandling.Ignore)]
        public Element? DefenderType { get; set; }

        [JsonProperty("multiplier", NullValueHandling = NullValueHandling.Ignore)]
        public double? Multiplier { get; set; }

        [JsonProperty("applier", NullValueHandling = NullValueHandling.Ignore)]
        public string Applier { get; set; }

        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; }

        [JsonProperty("markType", NullValueHandling = NullValueHandling.Ignore)]
        public string MarkType { get; set; }

        [JsonProperty("trigger", NullValueHandling = NullValueHandling.Ignore)]
        public string Trigger { get; set; }

        [JsonProperty("action", NullValueHandling = NullValueHandling.Ignore)]
        public string Action { get; set; }

        [JsonProperty("message", NullValueHandling = NullValueHandling.Ignore)]
        public string Message { get; set; }
    }

    public partial class MarkMessage
    {
        [JsonProperty("baseId", NullValueHandling = NullValueHandling.Ignore)]
        public string BaseId { get; set; }

        [JsonProperty("duration", NullValueHandling = NullValueHandling.Ignore)]
        public double? Duration { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("isActive", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IsActive { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("stack", NullValueHandling = NullValueHandling.Ignore)]
        public double? Stack { get; set; }
    }

    public partial class PlayerMessage
    {
        [JsonProperty("activePet", NullValueHandling = NullValueHandling.Ignore)]
        public PetMessage ActivePet { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("rage", NullValueHandling = NullValueHandling.Ignore)]
        public double? Rage { get; set; }

        [JsonProperty("team", NullValueHandling = NullValueHandling.Ignore)]
        public PetMessage[] Team { get; set; }

        [JsonProperty("teamAlives", NullValueHandling = NullValueHandling.Ignore)]
        public double? TeamAlives { get; set; }
    }

    public partial class PetMessage
    {
        [JsonProperty("currentHp", NullValueHandling = NullValueHandling.Ignore)]
        public double? CurrentHp { get; set; }

        [JsonProperty("element", NullValueHandling = NullValueHandling.Ignore)]
        public Element? Element { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("level", NullValueHandling = NullValueHandling.Ignore)]
        public double? Level { get; set; }

        [JsonProperty("marks", NullValueHandling = NullValueHandling.Ignore)]
        public MarkMessage[] Marks { get; set; }

        [JsonProperty("maxHp", NullValueHandling = NullValueHandling.Ignore)]
        public double? MaxHp { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("skills", NullValueHandling = NullValueHandling.Ignore)]
        public SkillMessage[] Skills { get; set; }

        [JsonProperty("speciesID", NullValueHandling = NullValueHandling.Ignore)]
        public string SpeciesId { get; set; }

        [JsonProperty("stats", NullValueHandling = NullValueHandling.Ignore)]
        public StatOnBattle Stats { get; set; }
    }

    public partial class SkillMessage
    {
        [JsonProperty("accuracy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Accuracy { get; set; }

        [JsonProperty("baseId", NullValueHandling = NullValueHandling.Ignore)]
        public string BaseId { get; set; }

        [JsonProperty("category", NullValueHandling = NullValueHandling.Ignore)]
        public Category? Category { get; set; }

        [JsonProperty("element", NullValueHandling = NullValueHandling.Ignore)]
        public Element? Element { get; set; }

        [JsonProperty("id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }

        [JsonProperty("multihit", NullValueHandling = NullValueHandling.Ignore)]
        public Multihit? Multihit { get; set; }

        [JsonProperty("name", NullValueHandling = NullValueHandling.Ignore)]
        public string Name { get; set; }

        [JsonProperty("power", NullValueHandling = NullValueHandling.Ignore)]
        public double? Power { get; set; }

        [JsonProperty("priority", NullValueHandling = NullValueHandling.Ignore)]
        public double? Priority { get; set; }

        [JsonProperty("rage", NullValueHandling = NullValueHandling.Ignore)]
        public double? Rage { get; set; }

        [JsonProperty("sureHit", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SureHit { get; set; }

        [JsonProperty("tag", NullValueHandling = NullValueHandling.Ignore)]
        public string[] Tag { get; set; }

        [JsonProperty("target", NullValueHandling = NullValueHandling.Ignore)]
        public AttackTargetOpinion? Target { get; set; }
    }

    public partial class StatOnBattle
    {
        [JsonProperty("accuracy", NullValueHandling = NullValueHandling.Ignore)]
        public double? Accuracy { get; set; }

        [JsonProperty("atk", NullValueHandling = NullValueHandling.Ignore)]
        public double? Atk { get; set; }

        [JsonProperty("critRate", NullValueHandling = NullValueHandling.Ignore)]
        public double? CritRate { get; set; }

        [JsonProperty("def", NullValueHandling = NullValueHandling.Ignore)]
        public double? Def { get; set; }

        [JsonProperty("evasion", NullValueHandling = NullValueHandling.Ignore)]
        public double? Evasion { get; set; }

        [JsonProperty("ragePerTurn", NullValueHandling = NullValueHandling.Ignore)]
        public double? RagePerTurn { get; set; }

        [JsonProperty("spa", NullValueHandling = NullValueHandling.Ignore)]
        public double? Spa { get; set; }

        [JsonProperty("spd", NullValueHandling = NullValueHandling.Ignore)]
        public double? Spd { get; set; }

        [JsonProperty("spe", NullValueHandling = NullValueHandling.Ignore)]
        public double? Spe { get; set; }
    }

    public enum Element { Ancient, Bug, Desert, Divine, Dragon, Electric, ElfKing, Fighting, Fire, Flying, Grass, Ground, Holy, Ice, Light, Miracle, Mystery, Normal, Psychic, Shadow, Trait, Water, Wind };

    public enum BattlePhase { Ended, ExecutionPhase, SelectionPhase, SwitchPhase };

    public enum DamageType { Effect, Physical, Special };

    public enum Category { Climax, Physical, Special, Status };

    public enum AttackTargetOpinion { Opponent, Self };

    public enum StatTypeOnBattle { Accuracy, Atk, CritRate, Def, Evasion, RagePerTurn, Spa, Spd, Spe };

    public enum BattleStatus { Ended, On, Unstarted };

    public enum TypeEnum { BattleEnd, BattleStart, BattleState, Crit, Damage, Error, FaintSwitch, ForcedSwitch, Heal, HpChange, Info, InvalidAction, MarkApply, MarkExpire, MarkTrigger, PetDefeated, PetRevive, PetSwitch, RageChange, RoundStart, SkillEffect, SkillMiss, SkillUse, StatChange, TurnAction, TypeEffectiveness };

    public partial struct Player
    {
        public string String;
        public string[] StringArray;

        public static implicit operator Player(string String) => new Player { String = String };
        public static implicit operator Player(string[] StringArray) => new Player { StringArray = StringArray };
    }

    public partial struct Multihit
    {
        public double? Double;
        public double[] DoubleArray;

        public static implicit operator Multihit(double Double) => new Multihit { Double = Double };
        public static implicit operator Multihit(double[] DoubleArray) => new Multihit { DoubleArray = DoubleArray };
    }

    public partial class BattleMessage
    {
        public static BattleMessage FromJson(string json) => JsonConvert.DeserializeObject<BattleMessage>(json, QuickType.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this BattleMessage self) => JsonConvert.SerializeObject(self, QuickType.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ElementConverter.Singleton,
                BattlePhaseConverter.Singleton,
                DamageTypeConverter.Singleton,
                PlayerConverter.Singleton,
                CategoryConverter.Singleton,
                MultihitConverter.Singleton,
                AttackTargetOpinionConverter.Singleton,
                StatTypeOnBattleConverter.Singleton,
                BattleStatusConverter.Singleton,
                TypeEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ElementConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Element) || t == typeof(Element?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ancient":
                    return Element.Ancient;
                case "Bug":
                    return Element.Bug;
                case "Desert":
                    return Element.Desert;
                case "Divine":
                    return Element.Divine;
                case "Dragon":
                    return Element.Dragon;
                case "Electric":
                    return Element.Electric;
                case "ElfKing":
                    return Element.ElfKing;
                case "Fighting":
                    return Element.Fighting;
                case "Fire":
                    return Element.Fire;
                case "Flying":
                    return Element.Flying;
                case "Grass":
                    return Element.Grass;
                case "Ground":
                    return Element.Ground;
                case "Holy":
                    return Element.Holy;
                case "Ice":
                    return Element.Ice;
                case "Light":
                    return Element.Light;
                case "Miracle":
                    return Element.Miracle;
                case "Mystery":
                    return Element.Mystery;
                case "Normal":
                    return Element.Normal;
                case "Psychic":
                    return Element.Psychic;
                case "Shadow":
                    return Element.Shadow;
                case "Trait":
                    return Element.Trait;
                case "Water":
                    return Element.Water;
                case "Wind":
                    return Element.Wind;
            }
            throw new Exception("Cannot unmarshal type Element");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Element)untypedValue;
            switch (value)
            {
                case Element.Ancient:
                    serializer.Serialize(writer, "Ancient");
                    return;
                case Element.Bug:
                    serializer.Serialize(writer, "Bug");
                    return;
                case Element.Desert:
                    serializer.Serialize(writer, "Desert");
                    return;
                case Element.Divine:
                    serializer.Serialize(writer, "Divine");
                    return;
                case Element.Dragon:
                    serializer.Serialize(writer, "Dragon");
                    return;
                case Element.Electric:
                    serializer.Serialize(writer, "Electric");
                    return;
                case Element.ElfKing:
                    serializer.Serialize(writer, "ElfKing");
                    return;
                case Element.Fighting:
                    serializer.Serialize(writer, "Fighting");
                    return;
                case Element.Fire:
                    serializer.Serialize(writer, "Fire");
                    return;
                case Element.Flying:
                    serializer.Serialize(writer, "Flying");
                    return;
                case Element.Grass:
                    serializer.Serialize(writer, "Grass");
                    return;
                case Element.Ground:
                    serializer.Serialize(writer, "Ground");
                    return;
                case Element.Holy:
                    serializer.Serialize(writer, "Holy");
                    return;
                case Element.Ice:
                    serializer.Serialize(writer, "Ice");
                    return;
                case Element.Light:
                    serializer.Serialize(writer, "Light");
                    return;
                case Element.Miracle:
                    serializer.Serialize(writer, "Miracle");
                    return;
                case Element.Mystery:
                    serializer.Serialize(writer, "Mystery");
                    return;
                case Element.Normal:
                    serializer.Serialize(writer, "Normal");
                    return;
                case Element.Psychic:
                    serializer.Serialize(writer, "Psychic");
                    return;
                case Element.Shadow:
                    serializer.Serialize(writer, "Shadow");
                    return;
                case Element.Trait:
                    serializer.Serialize(writer, "Trait");
                    return;
                case Element.Water:
                    serializer.Serialize(writer, "Water");
                    return;
                case Element.Wind:
                    serializer.Serialize(writer, "Wind");
                    return;
            }
            throw new Exception("Cannot marshal type Element");
        }

        public static readonly ElementConverter Singleton = new ElementConverter();
    }

    internal class BattlePhaseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattlePhase) || t == typeof(BattlePhase?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "ENDED":
                    return BattlePhase.Ended;
                case "EXECUTION_PHASE":
                    return BattlePhase.ExecutionPhase;
                case "SELECTION_PHASE":
                    return BattlePhase.SelectionPhase;
                case "SWITCH_PHASE":
                    return BattlePhase.SwitchPhase;
            }
            throw new Exception("Cannot unmarshal type BattlePhase");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattlePhase)untypedValue;
            switch (value)
            {
                case BattlePhase.Ended:
                    serializer.Serialize(writer, "ENDED");
                    return;
                case BattlePhase.ExecutionPhase:
                    serializer.Serialize(writer, "EXECUTION_PHASE");
                    return;
                case BattlePhase.SelectionPhase:
                    serializer.Serialize(writer, "SELECTION_PHASE");
                    return;
                case BattlePhase.SwitchPhase:
                    serializer.Serialize(writer, "SWITCH_PHASE");
                    return;
            }
            throw new Exception("Cannot marshal type BattlePhase");
        }

        public static readonly BattlePhaseConverter Singleton = new BattlePhaseConverter();
    }

    internal class DamageTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DamageType) || t == typeof(DamageType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "effect":
                    return DamageType.Effect;
                case "physical":
                    return DamageType.Physical;
                case "special":
                    return DamageType.Special;
            }
            throw new Exception("Cannot unmarshal type DamageType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DamageType)untypedValue;
            switch (value)
            {
                case DamageType.Effect:
                    serializer.Serialize(writer, "effect");
                    return;
                case DamageType.Physical:
                    serializer.Serialize(writer, "physical");
                    return;
                case DamageType.Special:
                    serializer.Serialize(writer, "special");
                    return;
            }
            throw new Exception("Cannot marshal type DamageType");
        }

        public static readonly DamageTypeConverter Singleton = new DamageTypeConverter();
    }

    internal class PlayerConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Player) || t == typeof(Player?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Player { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<string[]>(reader);
                    return new Player { StringArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Player");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Player)untypedValue;
            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }
            if (value.StringArray != null)
            {
                serializer.Serialize(writer, value.StringArray);
                return;
            }
            throw new Exception("Cannot marshal type Player");
        }

        public static readonly PlayerConverter Singleton = new PlayerConverter();
    }

    internal class CategoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Category) || t == typeof(Category?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Climax":
                    return Category.Climax;
                case "Physical":
                    return Category.Physical;
                case "Special":
                    return Category.Special;
                case "Status":
                    return Category.Status;
            }
            throw new Exception("Cannot unmarshal type Category");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Category)untypedValue;
            switch (value)
            {
                case Category.Climax:
                    serializer.Serialize(writer, "Climax");
                    return;
                case Category.Physical:
                    serializer.Serialize(writer, "Physical");
                    return;
                case Category.Special:
                    serializer.Serialize(writer, "Special");
                    return;
                case Category.Status:
                    serializer.Serialize(writer, "Status");
                    return;
            }
            throw new Exception("Cannot marshal type Category");
        }

        public static readonly CategoryConverter Singleton = new CategoryConverter();
    }

    internal class MultihitConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Multihit) || t == typeof(Multihit?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Multihit { Double = doubleValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<double[]>(reader);
                    return new Multihit { DoubleArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type Multihit");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Multihit)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.DoubleArray != null)
            {
                serializer.Serialize(writer, value.DoubleArray);
                return;
            }
            throw new Exception("Cannot marshal type Multihit");
        }

        public static readonly MultihitConverter Singleton = new MultihitConverter();
    }

    internal class AttackTargetOpinionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AttackTargetOpinion) || t == typeof(AttackTargetOpinion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "opponent":
                    return AttackTargetOpinion.Opponent;
                case "self":
                    return AttackTargetOpinion.Self;
            }
            throw new Exception("Cannot unmarshal type AttackTargetOpinion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AttackTargetOpinion)untypedValue;
            switch (value)
            {
                case AttackTargetOpinion.Opponent:
                    serializer.Serialize(writer, "opponent");
                    return;
                case AttackTargetOpinion.Self:
                    serializer.Serialize(writer, "self");
                    return;
            }
            throw new Exception("Cannot marshal type AttackTargetOpinion");
        }

        public static readonly AttackTargetOpinionConverter Singleton = new AttackTargetOpinionConverter();
    }

    internal class StatTypeOnBattleConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(StatTypeOnBattle) || t == typeof(StatTypeOnBattle?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "accuracy":
                    return StatTypeOnBattle.Accuracy;
                case "atk":
                    return StatTypeOnBattle.Atk;
                case "critRate":
                    return StatTypeOnBattle.CritRate;
                case "def":
                    return StatTypeOnBattle.Def;
                case "evasion":
                    return StatTypeOnBattle.Evasion;
                case "ragePerTurn":
                    return StatTypeOnBattle.RagePerTurn;
                case "spa":
                    return StatTypeOnBattle.Spa;
                case "spd":
                    return StatTypeOnBattle.Spd;
                case "spe":
                    return StatTypeOnBattle.Spe;
            }
            throw new Exception("Cannot unmarshal type StatTypeOnBattle");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (StatTypeOnBattle)untypedValue;
            switch (value)
            {
                case StatTypeOnBattle.Accuracy:
                    serializer.Serialize(writer, "accuracy");
                    return;
                case StatTypeOnBattle.Atk:
                    serializer.Serialize(writer, "atk");
                    return;
                case StatTypeOnBattle.CritRate:
                    serializer.Serialize(writer, "critRate");
                    return;
                case StatTypeOnBattle.Def:
                    serializer.Serialize(writer, "def");
                    return;
                case StatTypeOnBattle.Evasion:
                    serializer.Serialize(writer, "evasion");
                    return;
                case StatTypeOnBattle.RagePerTurn:
                    serializer.Serialize(writer, "ragePerTurn");
                    return;
                case StatTypeOnBattle.Spa:
                    serializer.Serialize(writer, "spa");
                    return;
                case StatTypeOnBattle.Spd:
                    serializer.Serialize(writer, "spd");
                    return;
                case StatTypeOnBattle.Spe:
                    serializer.Serialize(writer, "spe");
                    return;
            }
            throw new Exception("Cannot marshal type StatTypeOnBattle");
        }

        public static readonly StatTypeOnBattleConverter Singleton = new StatTypeOnBattleConverter();
    }

    internal class BattleStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BattleStatus) || t == typeof(BattleStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Ended":
                    return BattleStatus.Ended;
                case "On":
                    return BattleStatus.On;
                case "Unstarted":
                    return BattleStatus.Unstarted;
            }
            throw new Exception("Cannot unmarshal type BattleStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BattleStatus)untypedValue;
            switch (value)
            {
                case BattleStatus.Ended:
                    serializer.Serialize(writer, "Ended");
                    return;
                case BattleStatus.On:
                    serializer.Serialize(writer, "On");
                    return;
                case BattleStatus.Unstarted:
                    serializer.Serialize(writer, "Unstarted");
                    return;
            }
            throw new Exception("Cannot marshal type BattleStatus");
        }

        public static readonly BattleStatusConverter Singleton = new BattleStatusConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "BATTLE_END":
                    return TypeEnum.BattleEnd;
                case "BATTLE_START":
                    return TypeEnum.BattleStart;
                case "BATTLE_STATE":
                    return TypeEnum.BattleState;
                case "CRIT":
                    return TypeEnum.Crit;
                case "DAMAGE":
                    return TypeEnum.Damage;
                case "ERROR":
                    return TypeEnum.Error;
                case "FAINT_SWITCH":
                    return TypeEnum.FaintSwitch;
                case "FORCED_SWITCH":
                    return TypeEnum.ForcedSwitch;
                case "HEAL":
                    return TypeEnum.Heal;
                case "HP_CHANGE":
                    return TypeEnum.HpChange;
                case "INFO":
                    return TypeEnum.Info;
                case "INVALID_ACTION":
                    return TypeEnum.InvalidAction;
                case "MARK_APPLY":
                    return TypeEnum.MarkApply;
                case "MARK_EXPIRE":
                    return TypeEnum.MarkExpire;
                case "MARK_TRIGGER":
                    return TypeEnum.MarkTrigger;
                case "PET_DEFEATED":
                    return TypeEnum.PetDefeated;
                case "PET_REVIVE":
                    return TypeEnum.PetRevive;
                case "PET_SWITCH":
                    return TypeEnum.PetSwitch;
                case "RAGE_CHANGE":
                    return TypeEnum.RageChange;
                case "ROUND_START":
                    return TypeEnum.RoundStart;
                case "SKILL_EFFECT":
                    return TypeEnum.SkillEffect;
                case "SKILL_MISS":
                    return TypeEnum.SkillMiss;
                case "SKILL_USE":
                    return TypeEnum.SkillUse;
                case "STAT_CHANGE":
                    return TypeEnum.StatChange;
                case "TURN_ACTION":
                    return TypeEnum.TurnAction;
                case "TYPE_EFFECTIVENESS":
                    return TypeEnum.TypeEffectiveness;
            }
            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TypeEnum)untypedValue;
            switch (value)
            {
                case TypeEnum.BattleEnd:
                    serializer.Serialize(writer, "BATTLE_END");
                    return;
                case TypeEnum.BattleStart:
                    serializer.Serialize(writer, "BATTLE_START");
                    return;
                case TypeEnum.BattleState:
                    serializer.Serialize(writer, "BATTLE_STATE");
                    return;
                case TypeEnum.Crit:
                    serializer.Serialize(writer, "CRIT");
                    return;
                case TypeEnum.Damage:
                    serializer.Serialize(writer, "DAMAGE");
                    return;
                case TypeEnum.Error:
                    serializer.Serialize(writer, "ERROR");
                    return;
                case TypeEnum.FaintSwitch:
                    serializer.Serialize(writer, "FAINT_SWITCH");
                    return;
                case TypeEnum.ForcedSwitch:
                    serializer.Serialize(writer, "FORCED_SWITCH");
                    return;
                case TypeEnum.Heal:
                    serializer.Serialize(writer, "HEAL");
                    return;
                case TypeEnum.HpChange:
                    serializer.Serialize(writer, "HP_CHANGE");
                    return;
                case TypeEnum.Info:
                    serializer.Serialize(writer, "INFO");
                    return;
                case TypeEnum.InvalidAction:
                    serializer.Serialize(writer, "INVALID_ACTION");
                    return;
                case TypeEnum.MarkApply:
                    serializer.Serialize(writer, "MARK_APPLY");
                    return;
                case TypeEnum.MarkExpire:
                    serializer.Serialize(writer, "MARK_EXPIRE");
                    return;
                case TypeEnum.MarkTrigger:
                    serializer.Serialize(writer, "MARK_TRIGGER");
                    return;
                case TypeEnum.PetDefeated:
                    serializer.Serialize(writer, "PET_DEFEATED");
                    return;
                case TypeEnum.PetRevive:
                    serializer.Serialize(writer, "PET_REVIVE");
                    return;
                case TypeEnum.PetSwitch:
                    serializer.Serialize(writer, "PET_SWITCH");
                    return;
                case TypeEnum.RageChange:
                    serializer.Serialize(writer, "RAGE_CHANGE");
                    return;
                case TypeEnum.RoundStart:
                    serializer.Serialize(writer, "ROUND_START");
                    return;
                case TypeEnum.SkillEffect:
                    serializer.Serialize(writer, "SKILL_EFFECT");
                    return;
                case TypeEnum.SkillMiss:
                    serializer.Serialize(writer, "SKILL_MISS");
                    return;
                case TypeEnum.SkillUse:
                    serializer.Serialize(writer, "SKILL_USE");
                    return;
                case TypeEnum.StatChange:
                    serializer.Serialize(writer, "STAT_CHANGE");
                    return;
                case TypeEnum.TurnAction:
                    serializer.Serialize(writer, "TURN_ACTION");
                    return;
                case TypeEnum.TypeEffectiveness:
                    serializer.Serialize(writer, "TYPE_EFFECTIVENESS");
                    return;
            }
            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }
}
